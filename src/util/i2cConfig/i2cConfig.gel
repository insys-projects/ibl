#define TRUE  1
#define FALSE 0

#define ibl_MAGIC_VALUE  		 0xCEC11EBB

#define ibl_HIGHEST_PRIORITY     1  
#define ibl_LOWEST_PRIORITY     10
#define ibl_DEVICE_NOBOOT       20

#define SETIP(array,i0,i1,i2,i3)      array[0]=(i0);  \
                                      array[1]=(i1);  \
                                      array[2]=(i2);  \
                                      array[3]=(i3)

#define ibl_BOOT_FORMAT_AUTO    0
#define ibl_BOOT_FORMAT_NAME    1
#define ibl_BOOT_FORMAT_BIS     2
#define ibl_BOOT_FORMAT_COFF    3
#define ibl_BOOT_FORMAT_ELF     4
#define ibl_BOOT_FORMAT_BBLOB   5
#define ibl_BOOT_FORMAT_BTBL    6

#define ibl_MAIN_PLL    0
#define ibl_DDR_PLL     1
#define ibl_NET_PLL     2


menuitem "EVM c6472 IBL";

hotmenu setConfig_c6472()
{
    ibl.iblMagic = ibl_MAGIC_VALUE;

    ibl.pllConfig[ibl_MAIN_PLL].doEnable      = TRUE;
    ibl.pllConfig[ibl_MAIN_PLL].prediv        = 1;
    ibl.pllConfig[ibl_MAIN_PLL].mult          = 28;
    ibl.pllConfig[ibl_MAIN_PLL].postdiv       = 1;
    ibl.pllConfig[ibl_MAIN_PLL].pllOutFreqMhz = 700;

    /* The DDR PLL. The multipliers/dividers are fixed, so are really dont cares */
    ibl.pllConfig[ibl_DDR_PLL].doEnable = TRUE;

    /* The network PLL. The multipliers/dividers are fixed */
    ibl.pllConfig[ibl_NET_PLL].doEnable = TRUE;

    /* EMIF configuration. The values are for DDR at 533 MHz  */
    ibl.ddrConfig.configDdr = TRUE;

    ibl.ddrConfig.uEmif.emif3p1.sdcfg  = 0x00538832; /* timing, 32bit wide */
    ibl.ddrConfig.uEmif.emif3p1.sdrfc  = 0x0000073B; /* Refresh 533Mhz */ 
    ibl.ddrConfig.uEmif.emif3p1.sdtim1 = 0x47245BD2; /* Timing 1 */
    ibl.ddrConfig.uEmif.emif3p1.sdtim2 = 0x0125DC44; /* Timing 2 */
    ibl.ddrConfig.uEmif.emif3p1.dmcctl = 0x50001906; /* PHY read latency for CAS 5 is 5 + 2 - 1 */

    /* Ethernet configuration for port 0 */
    ibl.ethConfig[0].ethPriority      = ibl_HIGHEST_PRIORITY;
    ibl.ethConfig[0].port             = 0;

    /* Bootp is disabled. The server and file name are provided here */
    ibl.ethConfig[0].doBootp          = FALSE;
    ibl.ethConfig[0].useBootpServerIp = FALSE;
    ibl.ethConfig[0].useBootpFileName = FALSE;
    ibl.ethConfig[0].bootFormat       = ibl_BOOT_FORMAT_AUTO;


    SETIP(ibl.ethConfig[0].ethInfo.ipAddr,    10,218,109,21);
    SETIP(ibl.ethConfig[0].ethInfo.serverIp,  10,218,109,196);
    SETIP(ibl.ethConfig[0].ethInfo.gatewayIp, 10,218,109,2);
    SETIP(ibl.ethConfig[0].ethInfo.netmask,   255,255,255,0);

    /* Leave the hardware address as 0 so the e-fuse value will be used */




    ibl.ethConfig[0].ethInfo.fileName[0]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[1]  = 'e';
    ibl.ethConfig[0].ethInfo.fileName[2]  = 's';
    ibl.ethConfig[0].ethInfo.fileName[3]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[4]  = '.';
    ibl.ethConfig[0].ethInfo.fileName[5]  = 'o';
    ibl.ethConfig[0].ethInfo.fileName[6]  = 'u';
    ibl.ethConfig[0].ethInfo.fileName[7]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[8]  = '\0';
    ibl.ethConfig[0].ethInfo.fileName[9]  = '\0';
    ibl.ethConfig[0].ethInfo.fileName[10] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[11] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[12] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[13] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[14] = '\0';

    /* Even though the entire range of DDR2 is chosen, the load will
     * stop when the ftp reaches the end of the file */
    ibl.ethConfig[0].blob.startAddress  = 0xe0000000;       /* Base address of DDR2 */
    ibl.ethConfig[0].blob.sizeBytes     = 0x20000000;       /* All of DDR2 */
    ibl.ethConfig[0].blob.branchAddress = 0xe0000000;       /* Base of DDR2 */

    /* For port 1 use bootp */
    /* Ethernet configuration for port 0 */
    ibl.ethConfig[1].ethPriority      = ibl_HIGHEST_PRIORITY + 1;
    ibl.ethConfig[1].port             = 1;

    /* Bootp is disabled. The server and file name are provided here */
    ibl.ethConfig[1].doBootp          = TRUE;
    ibl.ethConfig[1].useBootpServerIp = TRUE;
    ibl.ethConfig[1].useBootpFileName = TRUE;
    ibl.ethConfig[1].bootFormat       = ibl_BOOT_FORMAT_AUTO;


    /* SGMII not present */
	ibl.sgmiiConfig[0].adviseAbility = 0;
	ibl.sgmiiConfig[0].control       = 0;
	ibl.sgmiiConfig[0].txConfig      = 0;
	ibl.sgmiiConfig[0].rxConfig      = 0;
	ibl.sgmiiConfig[0].auxConfig     = 0;

	ibl.sgmiiConfig[1].adviseAbility = 0;
	ibl.sgmiiConfig[1].control       = 0;
	ibl.sgmiiConfig[1].txConfig      = 0;
	ibl.sgmiiConfig[1].rxConfig      = 0;
	ibl.sgmiiConfig[1].auxConfig     = 0;


    /* Leave the hardware address as 0 so the e-fuse value will be used */
    ibl.ethConfig[0].ethInfo.hwAddress[0] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[1] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[2] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[3] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[4] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[5] = 0;


    /* Leave all remaining fields as 0 since bootp will fill them in */


    /* Even though the entire range of DDR2 is chosen, the load will */
    /* stop when the ftp reaches the end of the file */
 
    ibl.ethConfig[1].blob.startAddress  = 0xe0000000;       /* Base address of DDR2 */
    ibl.ethConfig[1].blob.sizeBytes     = 0x20000000;       /* All of DDR2 */
    ibl.ethConfig[1].blob.branchAddress = 0xe0000000;       /* Base of DDR2 */
    


    /* MDIO configuration */
    ibl.mdioConfig.nMdioOps = 8;
    ibl.mdioConfig.mdioClkDiv = 0x20;
    ibl.mdioConfig.interDelay = 1400;   /* ~2ms at 700 MHz */

    ibl.mdioConfig.mdio[0] =  (1 << 30) | (27 << 21) | (24 << 16) | 0x848b;
    ibl.mdioConfig.mdio[1] =  (1 << 30) | (20 << 21) | (24 << 16) | 0x0ce0;
    ibl.mdioConfig.mdio[2] =  (1 << 30) | (24 << 21) | (24 << 16) | 0x4101;
    ibl.mdioConfig.mdio[3] =  (1 << 30) | ( 0 << 21) | (24 << 16) | 0x9140;

    ibl.mdioConfig.mdio[4] =  (1 << 30) | (27 << 21) | (25 << 16) | 0x848b;
    ibl.mdioConfig.mdio[5] =  (1 << 30) | (20 << 21) | (25 << 16) | 0x0ce0;
    ibl.mdioConfig.mdio[6] =  (1 << 30) | (24 << 21) | (25 << 16) | 0x4101;
    ibl.mdioConfig.mdio[7] =  (1 << 30) | ( 0 << 21) | (25 << 16) | 0x9140;


    /* Nand boot is disabled */
    ibl.nandConfig.nandPriority = ibl_DEVICE_NOBOOT;

    ibl.nandConfig.bootFormat   = ibl_BOOT_FORMAT_AUTO;

    ibl.nandConfig.nandInfo.busWidthBits  = 8;
    ibl.nandConfig.nandInfo.pageSizeBytes = 2048;
    ibl.nandConfig.nandInfo.pageEccBytes  = 64;
    ibl.nandConfig.nandInfo.pagesPerBlock = 64;
    ibl.nandConfig.nandInfo.totalBlocks   = 1024;

    ibl.nandConfig.nandInfo.addressBytes  = 4;
    ibl.nandConfig.nandInfo.lsbFirst      = TRUE;
    ibl.nandConfig.nandInfo.blockOffset   = 22;
    ibl.nandConfig.nandInfo.pageOffset    = 16;
    ibl.nandConfig.nandInfo.columnOffset  = 0;

    ibl.nandConfig.nandInfo.resetCommand    = 0xff;
    ibl.nandConfig.nandInfo.readCommandPre  = 0;
    ibl.nandConfig.nandInfo.readCommandPost = 0x30;
    ibl.nandConfig.nandInfo.postCommand     = TRUE;

}


menuitem "EVM c6474 Mez IBL";

hotmenu setConfig_c6474()
{
    ibl.iblMagic = ibl_MAGIC_VALUE;

    ibl.pllConfig[ibl_MAIN_PLL].doEnable      = TRUE;
    ibl.pllConfig[ibl_MAIN_PLL].prediv        = 1;
    ibl.pllConfig[ibl_MAIN_PLL].mult          = 20;
    ibl.pllConfig[ibl_MAIN_PLL].postdiv       = 1;
    ibl.pllConfig[ibl_MAIN_PLL].pllOutFreqMhz = 1000;

    /* The DDR PLL. The multipliers/dividers are fixed, so are really dont cares */
    ibl.pllConfig[ibl_DDR_PLL].doEnable = TRUE;

    /* The network PLL. The multipliers/dividers are fixed */
    ibl.pllConfig[ibl_NET_PLL].doEnable = TRUE;

    /* EMIF configuration. The values are for DDR at 533 MHz  */
    ibl.ddrConfig.configDdr = TRUE;

    ibl.ddrConfig.uEmif.emif3p1.sdcfg  = 0x00d38a32; /* cas5, 8 banks, 10 bit column */
    ibl.ddrConfig.uEmif.emif3p1.sdrfc  = 0x00000a29; /* Refresh 333Mhz */ 
    ibl.ddrConfig.uEmif.emif3p1.sdtim1 = 0x4d246c9a; /* Timing 1 */
    ibl.ddrConfig.uEmif.emif3p1.sdtim2 = 0x00993c42; /* Timing 2 */
    ibl.ddrConfig.uEmif.emif3p1.dmcctl = 0x50001906; /* PHY read latency for CAS 5 is 5 + 2 - 1 */


    /* Ethernet configuration for port 0 */
    ibl.ethConfig[0].ethPriority      = ibl_HIGHEST_PRIORITY;
    ibl.ethConfig[0].port             = 0;

    /* Bootp is disabled. The server and file name are provided here */
    ibl.ethConfig[0].doBootp          = FALSE;
    ibl.ethConfig[0].useBootpServerIp = FALSE;
    ibl.ethConfig[0].useBootpFileName = FALSE;
    ibl.ethConfig[0].bootFormat       = ibl_BOOT_FORMAT_BBLOB;

    SETIP(ibl.ethConfig[0].ethInfo.ipAddr,    10,218,109,35);
    SETIP(ibl.ethConfig[0].ethInfo.serverIp,  10,218,109,196);
    SETIP(ibl.ethConfig[0].ethInfo.gatewayIp, 10,218,109,1);
    SETIP(ibl.ethConfig[0].ethInfo.netmask,   255,255,255,0);

    /* Set the hardware address as 0 so the e-fuse value will be used */
    ibl.ethConfig[0].ethInfo.hwAddress[0] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[1] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[2] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[3] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[4] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[5] = 0;


    ibl.ethConfig[0].ethInfo.fileName[0]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[1]  = 'e';
    ibl.ethConfig[0].ethInfo.fileName[2]  = 's';
    ibl.ethConfig[0].ethInfo.fileName[3]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[4]  = '.';
    ibl.ethConfig[0].ethInfo.fileName[5]  = 'b';
    ibl.ethConfig[0].ethInfo.fileName[6]  = 'l';
    ibl.ethConfig[0].ethInfo.fileName[7]  = 'o';
    ibl.ethConfig[0].ethInfo.fileName[8]  = 'b';
    ibl.ethConfig[0].ethInfo.fileName[9]  = '\0';
    ibl.ethConfig[0].ethInfo.fileName[10] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[11] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[12] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[13] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[14] = '\0';


    /* Even though the entire range of DDR2 is chosen, the load will
     * stop when the ftp reaches the end of the file */
    ibl.ethConfig[0].blob.startAddress  = 0x80000000;       /* Base address of DDR2 */
    ibl.ethConfig[0].blob.sizeBytes     = 0x20000000;       /* All of DDR2 */
    ibl.ethConfig[0].blob.branchAddress = 0x80000000;       /* Base of DDR2 */

    /* There is no port 1 on the 6474 */
    ibl.ethConfig[1].ethPriority      = ibl_DEVICE_NOBOOT;

    /* SGMII is present */
    ibl.sgmiiConfig[0].adviseAbility = 0x9801;
    ibl.sgmiiConfig[0].control       = 0x20;
    ibl.sgmiiConfig[0].txConfig      = 0x00000ea3;
    ibl.sgmiiConfig[0].rxConfig      = 0x00081023;
    ibl.sgmiiConfig[0].auxConfig     = 0x0000000b;

    /* MDIO configuration */
    ibl.mdioConfig.nMdioOps = 8;
    ibl.mdioConfig.mdioClkDiv = 0x26;
    ibl.mdioConfig.interDelay = 2000;   /* ~2ms at 1000 MHz */

    ibl.mdioConfig.mdio[0] =  (1 << 30) | ( 4 << 21) | (27 << 16) | 0x0081;
    ibl.mdioConfig.mdio[1] =  (1 << 30) | (26 << 21) | (15 << 16) | 0x0047;
    ibl.mdioConfig.mdio[2] =  (1 << 30) | (26 << 21) | (14 << 16) | 0x0047;
    ibl.mdioConfig.mdio[3] =  (1 << 30) | ( 0 << 21) | (15 << 16) | 0x8140;

    ibl.mdioConfig.mdio[4] =  (1 << 30) | ( 0 << 21) | (14 << 16) | 0x8140;
    ibl.mdioConfig.mdio[5] =  (1 << 30) | ( 1 << 21) | (22 << 16) | 0x043e;
    ibl.mdioConfig.mdio[6] =  (1 << 30) | ( 1 << 21) | (22 << 16) | 0x043e;
    ibl.mdioConfig.mdio[7] =  (1 << 30) | ( 0 << 21) | ( 1 << 16) | 0xa100;


    /* Nand boot is disabled */
    ibl.nandConfig.nandPriority = ibl_DEVICE_NOBOOT;

}

menuitem "EVM c6474 Lite EVM IBL";

hotmenu setConfig_c6474lite()
{
    ibl.iblMagic = ibl_MAGIC_VALUE;

    ibl.pllConfig[ibl_MAIN_PLL].doEnable      = TRUE;
    ibl.pllConfig[ibl_MAIN_PLL].prediv        = 1;
    ibl.pllConfig[ibl_MAIN_PLL].mult          = 20;
    ibl.pllConfig[ibl_MAIN_PLL].postdiv       = 1;
    ibl.pllConfig[ibl_MAIN_PLL].pllOutFreqMhz = 1000;

    /* The DDR PLL. The multipliers/dividers are fixed, so are really dont cares */
    ibl.pllConfig[ibl_DDR_PLL].doEnable = TRUE;

    /* The network PLL. The multipliers/dividers are fixed */
    ibl.pllConfig[ibl_NET_PLL].doEnable = TRUE;

    /* EMIF configuration. The values are for DDR at 533 MHz  */
    ibl.ddrConfig.configDdr = TRUE;

    ibl.ddrConfig.uEmif.emif3p1.sdcfg  = 0x00d38a32; /* cas5, 8 banks, 10 bit column */
    ibl.ddrConfig.uEmif.emif3p1.sdrfc  = 0x00000a29; /* Refresh 333Mhz */ 
    ibl.ddrConfig.uEmif.emif3p1.sdtim1 = 0x4d246c9a; /* Timing 1 */
    ibl.ddrConfig.uEmif.emif3p1.sdtim2 = 0x00993c42; /* Timing 2 */
    ibl.ddrConfig.uEmif.emif3p1.dmcctl = 0x50001906; /* PHY read latency for CAS 5 is 5 + 2 - 1 */


    /* Ethernet configuration for port 0 */
    ibl.ethConfig[0].ethPriority      = ibl_HIGHEST_PRIORITY;
    ibl.ethConfig[0].port             = 0;

    /* Bootp is disabled. The server and file name are provided here */
    ibl.ethConfig[0].doBootp          = FALSE;
    ibl.ethConfig[0].useBootpServerIp = FALSE;
    ibl.ethConfig[0].useBootpFileName = FALSE;
    ibl.ethConfig[0].bootFormat       = ibl_BOOT_FORMAT_BBLOB;

    SETIP(ibl.ethConfig[0].ethInfo.ipAddr,    158,218,100,114);
    SETIP(ibl.ethConfig[0].ethInfo.serverIp,  158,218,100,25);
    SETIP(ibl.ethConfig[0].ethInfo.gatewayIp, 158,218,100,2);
    SETIP(ibl.ethConfig[0].ethInfo.netmask,   255,255,255,0);

    /* Set the hardware address as 0 so the e-fuse value will be used */
    ibl.ethConfig[0].ethInfo.hwAddress[0] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[1] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[2] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[3] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[4] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[5] = 0;


    ibl.ethConfig[0].ethInfo.fileName[0]  = 'c';
    ibl.ethConfig[0].ethInfo.fileName[1]  = '6';
    ibl.ethConfig[0].ethInfo.fileName[2]  = '4';
    ibl.ethConfig[0].ethInfo.fileName[3]  = '7';
    ibl.ethConfig[0].ethInfo.fileName[4]  = '4';
    ibl.ethConfig[0].ethInfo.fileName[5]  = 'l';
    ibl.ethConfig[0].ethInfo.fileName[6]  = '-';
    ibl.ethConfig[0].ethInfo.fileName[7]  = 'l';
    ibl.ethConfig[0].ethInfo.fileName[8]  = 'e';
    ibl.ethConfig[0].ethInfo.fileName[9]  = '.';
    ibl.ethConfig[0].ethInfo.fileName[10] = 'b';
    ibl.ethConfig[0].ethInfo.fileName[11] = 'i';
    ibl.ethConfig[0].ethInfo.fileName[12] = 'n';
    ibl.ethConfig[0].ethInfo.fileName[13] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[14] = '\0';


    /* Even though the entire range of DDR2 is chosen, the load will
     * stop when the ftp reaches the end of the file */
    ibl.ethConfig[0].blob.startAddress  = 0x80000000;       /* Base address of DDR2 */
    ibl.ethConfig[0].blob.sizeBytes     = 0x20000000;       /* All of DDR2 */
    ibl.ethConfig[0].blob.branchAddress = 0x80000000;       /* Base of DDR2 */

    /* There is no port 1 on the 6474 Lite EVM */
    ibl.ethConfig[1].ethPriority      = ibl_DEVICE_NOBOOT;

    /* SGMII is present */
    ibl.sgmiiConfig[0].adviseAbility = 0x9801;
    ibl.sgmiiConfig[0].control       = 0x20;
    ibl.sgmiiConfig[0].txConfig      = 0x00000e23;
    ibl.sgmiiConfig[0].rxConfig      = 0x00081023;
    ibl.sgmiiConfig[0].auxConfig     = 0x0000000b;

    /* MDIO configuration */
    ibl.mdioConfig.nMdioOps = 8;
    ibl.mdioConfig.mdioClkDiv = 0x26;
    ibl.mdioConfig.interDelay = 2000;   /* ~2ms at 1000 MHz */

    ibl.mdioConfig.mdio[0] =  (1 << 30) | ( 4 << 21) | (27 << 16) | 0x0081;
    ibl.mdioConfig.mdio[1] =  (1 << 30) | (26 << 21) | (15 << 16) | 0x0047;
    ibl.mdioConfig.mdio[2] =  (1 << 30) | (26 << 21) | (14 << 16) | 0x0047;
    ibl.mdioConfig.mdio[3] =  (1 << 30) | ( 0 << 21) | (15 << 16) | 0x8140;

    ibl.mdioConfig.mdio[4] =  (1 << 30) | ( 0 << 21) | (14 << 16) | 0x8140;
    ibl.mdioConfig.mdio[5] =  (1 << 30) | ( 1 << 21) | (22 << 16) | 0x043e;
    ibl.mdioConfig.mdio[6] =  (1 << 30) | ( 1 << 21) | (22 << 16) | 0x043e;
    ibl.mdioConfig.mdio[7] =  (1 << 30) | ( 0 << 21) | ( 1 << 16) | 0xa100;


    /* This board has NAND. We will enable later */
    ibl.nandConfig.nandPriority = ibl_DEVICE_NOBOOT;

}

menuitem "EVM c6457 EVM IBL";

hotmenu setConfig_c6457()
{
    ibl.iblMagic = ibl_MAGIC_VALUE;

    ibl.pllConfig[ibl_MAIN_PLL].doEnable      = TRUE;
    ibl.pllConfig[ibl_MAIN_PLL].prediv        = 1;
    ibl.pllConfig[ibl_MAIN_PLL].mult          = 20;
    ibl.pllConfig[ibl_MAIN_PLL].postdiv       = 1;
    ibl.pllConfig[ibl_MAIN_PLL].pllOutFreqMhz = 1000;

    /* The DDR PLL. The multipliers/dividers are fixed, so are really dont cares */
    ibl.pllConfig[ibl_DDR_PLL].doEnable = TRUE;

    /* The network PLL. The multipliers/dividers are fixed */
    ibl.pllConfig[ibl_NET_PLL].doEnable = TRUE;

    /* EMIF configuration */
    ibl.ddrConfig.configDdr = TRUE;

    ibl.ddrConfig.uEmif.emif3p1.sdcfg  = 0x00d38a32; /* cas5, 8 banks, 10 bit column */
    ibl.ddrConfig.uEmif.emif3p1.sdrfc  = 0x00000a0e; /* Refresh 333Mhz */ 
    ibl.ddrConfig.uEmif.emif3p1.sdtim1 = 0x832474da; /* Timing 1 */
    ibl.ddrConfig.uEmif.emif3p1.sdtim2 = 0x3d44c742; /* Timing 2 */
    ibl.ddrConfig.uEmif.emif3p1.dmcctl = 0x50001906; /* PHY read latency for CAS 5 is 5 + 2 - 1 */


    /* Ethernet configuration for port 0 */
    ibl.ethConfig[0].ethPriority      = ibl_HIGHEST_PRIORITY;
    ibl.ethConfig[0].port             = 0;

    /* Bootp is disabled. The server and file name are provided here */
    ibl.ethConfig[0].doBootp          = FALSE;
    ibl.ethConfig[0].useBootpServerIp = FALSE;
    ibl.ethConfig[0].useBootpFileName = FALSE;
    ibl.ethConfig[0].bootFormat       = ibl_BOOT_FORMAT_BBLOB;

    SETIP(ibl.ethConfig[0].ethInfo.ipAddr,    158,218,100,115);
    SETIP(ibl.ethConfig[0].ethInfo.serverIp,  158,218,100,25);
    SETIP(ibl.ethConfig[0].ethInfo.gatewayIp, 158,218,100,2);
    SETIP(ibl.ethConfig[0].ethInfo.netmask,   255,255,255,0);

    /* Set the hardware address as 0 so the e-fuse value will be used */
    ibl.ethConfig[0].ethInfo.hwAddress[0] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[1] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[2] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[3] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[4] = 0;
    ibl.ethConfig[0].ethInfo.hwAddress[5] = 0;


    ibl.ethConfig[0].ethInfo.fileName[0]  = 'c';
    ibl.ethConfig[0].ethInfo.fileName[1]  = '6';
    ibl.ethConfig[0].ethInfo.fileName[2]  = '4';
    ibl.ethConfig[0].ethInfo.fileName[3]  = '5';
    ibl.ethConfig[0].ethInfo.fileName[4]  = '7';
    ibl.ethConfig[0].ethInfo.fileName[5]  = '-';
    ibl.ethConfig[0].ethInfo.fileName[6]  = 'l';
    ibl.ethConfig[0].ethInfo.fileName[7]  = 'e';
    ibl.ethConfig[0].ethInfo.fileName[8]  = '.';
    ibl.ethConfig[0].ethInfo.fileName[9]  = 'b';
    ibl.ethConfig[0].ethInfo.fileName[10] = 'i';
    ibl.ethConfig[0].ethInfo.fileName[11] = 'n';
    ibl.ethConfig[0].ethInfo.fileName[12] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[13] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[14] = '\0';


    /* Even though the entire range of DDR2 is chosen, the load will
     * stop when the ftp reaches the end of the file */
    ibl.ethConfig[0].blob.startAddress  = 0xe0000000;       /* Base address of DDR2 */
    ibl.ethConfig[0].blob.sizeBytes     = 0x20000000;       /* All of DDR2 */
    ibl.ethConfig[0].blob.branchAddress = 0xe0000000;       /* Base of DDR2 */

    /* There is no port 1 on the 6457 Lite EVM */
    ibl.ethConfig[1].ethPriority      = ibl_DEVICE_NOBOOT;

    /* SGMII is present */
    ibl.sgmiiConfig[0].adviseAbility = 0x9801;
    ibl.sgmiiConfig[0].control       = 0x20;
    ibl.sgmiiConfig[0].txConfig      = 0x00000e23;
    ibl.sgmiiConfig[0].rxConfig      = 0x00081023;
    ibl.sgmiiConfig[0].auxConfig     = 0x0000000b;

    /* MDIO configuration */
    ibl.mdioConfig.nMdioOps = 8;
    ibl.mdioConfig.mdioClkDiv = 0x26;
    ibl.mdioConfig.interDelay = 2000;   /* ~2ms at 1000 MHz */

    ibl.mdioConfig.mdio[0] =  (1 << 30) | ( 4 << 21) | (27 << 16) | 0x0081;
    ibl.mdioConfig.mdio[1] =  (1 << 30) | (26 << 21) | (15 << 16) | 0x0047;
    ibl.mdioConfig.mdio[2] =  (1 << 30) | (26 << 21) | (14 << 16) | 0x0047;
    ibl.mdioConfig.mdio[3] =  (1 << 30) | ( 0 << 21) | (15 << 16) | 0x8140;

    ibl.mdioConfig.mdio[4] =  (1 << 30) | ( 0 << 21) | (14 << 16) | 0x8140;
    ibl.mdioConfig.mdio[5] =  (1 << 30) | ( 1 << 21) | (22 << 16) | 0x043e;
    ibl.mdioConfig.mdio[6] =  (1 << 30) | ( 1 << 21) | (22 << 16) | 0x043e;
    ibl.mdioConfig.mdio[7] =  (1 << 30) | ( 0 << 21) | ( 1 << 16) | 0xa100;


    /* This board has NAND. We will enable later */
    ibl.nandConfig.nandPriority = ibl_DEVICE_NOBOOT;

}

menuitem "EVM c6455 IBL";

hotmenu setConfig_c6455()
{
    ibl.iblMagic = ibl_MAGIC_VALUE;

    ibl.pllConfig[ibl_MAIN_PLL].doEnable      = TRUE;
    ibl.pllConfig[ibl_MAIN_PLL].prediv        = 1;
    ibl.pllConfig[ibl_MAIN_PLL].mult          = 20;
    ibl.pllConfig[ibl_MAIN_PLL].postdiv       = 1;
    ibl.pllConfig[ibl_MAIN_PLL].pllOutFreqMhz = 1000;

    /* The DDR PLL. The multipliers/dividers are fixed, so are really dont cares */
    ibl.pllConfig[ibl_DDR_PLL].doEnable = TRUE;

    /* The network PLL. The multipliers/dividers are fixed */
    ibl.pllConfig[ibl_NET_PLL].doEnable = TRUE;

    /* EMIF configuration. The values are for DDR at 500 MHz  */
    ibl.ddrConfig.configDdr = TRUE;

    ibl.ddrConfig.uEmif.emif3p1.sdcfg  = 0x00538822; /* timing, 32bit wide */
    ibl.ddrConfig.uEmif.emif3p1.sdrfc  = 0x000007a2; /* Refresh 500Mhz */ 
    ibl.ddrConfig.uEmif.emif3p1.sdtim1 = 0x3edb4b91; /* Timing 1 */
    ibl.ddrConfig.uEmif.emif3p1.sdtim2 = 0x00a2c722; /* Timing 2 */
    ibl.ddrConfig.uEmif.emif3p1.dmcctl = 0x00000005; /* PHY read latency for CAS 4 is 4 + 2 - 1 */

    /* Ethernet configuration for port 0 */
    ibl.ethConfig[0].ethPriority      = ibl_HIGHEST_PRIORITY;
    ibl.ethConfig[0].port             = 0;

    /* Bootp is disabled. The server and file name are provided here */
    ibl.ethConfig[0].doBootp          = FALSE;
    ibl.ethConfig[0].useBootpServerIp = FALSE;
    ibl.ethConfig[0].useBootpFileName = FALSE;
    ibl.ethConfig[0].bootFormat       = ibl_BOOT_FORMAT_BBLOB;


    SETIP(ibl.ethConfig[0].ethInfo.ipAddr,    158,218,100,118);
    SETIP(ibl.ethConfig[0].ethInfo.serverIp,  158,218,100,25);
    SETIP(ibl.ethConfig[0].ethInfo.gatewayIp, 158,218,100,2);
    SETIP(ibl.ethConfig[0].ethInfo.netmask,   255,255,255,0);

    /* There is no e-fuse mac address. A value must be assigned */
    ibl.ethConfig[0].ethInfo.hwAddress[0] = 10;
    ibl.ethConfig[0].ethInfo.hwAddress[1] = 224;
    ibl.ethConfig[0].ethInfo.hwAddress[2] = 166;
    ibl.ethConfig[0].ethInfo.hwAddress[3] = 102;
    ibl.ethConfig[0].ethInfo.hwAddress[4] = 87;
    ibl.ethConfig[0].ethInfo.hwAddress[5] = 25;


    ibl.ethConfig[0].ethInfo.fileName[0]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[1]  = 'e';
    ibl.ethConfig[0].ethInfo.fileName[2]  = 's';
    ibl.ethConfig[0].ethInfo.fileName[3]  = 't';
    ibl.ethConfig[0].ethInfo.fileName[4]  = '.';
    ibl.ethConfig[0].ethInfo.fileName[5]  = 'b';
    ibl.ethConfig[0].ethInfo.fileName[6]  = 'l';
    ibl.ethConfig[0].ethInfo.fileName[7]  = 'o';
    ibl.ethConfig[0].ethInfo.fileName[8]  = 'b';
    ibl.ethConfig[0].ethInfo.fileName[9]  = '\0';
    ibl.ethConfig[0].ethInfo.fileName[10] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[11] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[12] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[13] = '\0';
    ibl.ethConfig[0].ethInfo.fileName[14] = '\0';


    /* Even though the entire range of DDR2 is chosen, the load will
     * stop when the ftp reaches the end of the file */
    ibl.ethConfig[0].blob.startAddress  = 0xe0000000;       /* Base address of DDR2 */
    ibl.ethConfig[0].blob.sizeBytes     = 0x20000000;       /* All of DDR2 */
    ibl.ethConfig[0].blob.branchAddress = 0xe0000000;       /* Base of DDR2 */

    /* There is no ethernet port 1 */
    ibl.ethConfig[1].ethPriority      = ibl_DEVICE_NOBOOT;


    /* SGMII not present */
	ibl.sgmiiConfig[0].adviseAbility = 0;
	ibl.sgmiiConfig[0].control       = 0;
	ibl.sgmiiConfig[0].txConfig      = 0;
	ibl.sgmiiConfig[0].rxConfig      = 0;
	ibl.sgmiiConfig[0].auxConfig     = 0;

	ibl.sgmiiConfig[1].adviseAbility = 0;
	ibl.sgmiiConfig[1].control       = 0;
	ibl.sgmiiConfig[1].txConfig      = 0;
	ibl.sgmiiConfig[1].rxConfig      = 0;
	ibl.sgmiiConfig[1].auxConfig     = 0;



    /* MDIO configuration */
    ibl.mdioConfig.nMdioOps = 0;
    ibl.mdioConfig.mdioClkDiv = 0x20;
    ibl.mdioConfig.interDelay = 2000;   /* ~2ms at 1000 MHz */

    ibl.mdioConfig.mdio[0] =  (1 << 30) | (14 << 21) | (0 << 16) | 0xd5d0;


    /* Nand boot is disabled */
    ibl.nandConfig.nandPriority = ibl_DEVICE_NOBOOT;

}


